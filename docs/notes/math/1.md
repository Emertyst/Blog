# 多项式全家桶

!!! note "代码"

    ```cpp
    #include <algorithm>
    #include <cmath>
    #include <initializer_list>
    #include <iostream>
    #include <unordered_map>
    #include <vector>
    using namespace std;
    const int MOD = 998244353, G = 3;
    unordered_map<int, int> mp;
    namespace Math {
    int inc(int a, int b) { return a + b >= MOD ? a + b - MOD : a + b; }
    int dec(int a, int b) { return a < b ? a - b + MOD : a - b; }
    int mul(int a, int b) { return 1ll * a * b % MOD; }
    int mod(int a) { return (a % MOD + MOD) % MOD; }
    int power(int a, int b) {
        int ans = 1;
        for (; b; b >>= 1, a = mul(a, a))
            if (b & 1)
                ans = mul(ans, a);
        return ans;
    }
    int inv(int a) { return power(a, MOD - 2); }
    int bsgs(int x) {
        mp.clear();
        int k = (int)::sqrt(MOD) + 1;
        for (int i = 1, t = mul(x, G); i <= k; ++i, t = mul(t, G))
            mp[t] = i;
        for (int i = 1, u = power(G, k), t = u; i <= k; ++i, t = mul(t, u))
            if (mp.count(t))
                return i * k - mp[t];
        return -1;
    }
    int sqrt(int x) {
        if (x == 0)
            return 0;
        int tmp = power(G, bsgs(x) >> 1);
        return min(tmp, MOD - tmp);
    }
    } // namespace Math
    using namespace Math;
    class Poly : public vector<int> {
    private:
        static const int LG = 18, N = 1 << LG, MAXN = N + 5;
        static int w[MAXN], rev[MAXN], fac[MAXN], iFac[MAXN];

        static void init() {
            int u = power(G, (MOD - 1) >> LG);
            w[N >> 1] = 1;
            for (int i = (N >> 1) + 1; i < N; ++i)
                w[i] = mul(w[i - 1], u);
            for (int i = (N >> 1) - 1; i; --i)
                w[i] = w[i << 1];
            for (int i = 1; i < N; ++i)
                rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (LG - 1));
        }
        static void getFac() {
            fac[0] = 1;
            for (int i = 1; i <= N; ++i)
                fac[i] = mul(fac[i - 1], i);
            iFac[N] = power(fac[N], MOD - 2);
            for (int i = N; i; --i)
                iFac[i - 1] = mul(iFac[i], i);
        }
        static int getLen(int n) {
            int lg = 0;
            while ((1 << lg) < n)
                ++lg;
            return lg;
        }
        static void ntt(Poly &a, int lg, bool inv) {
            if (!rev[1])
                init();
            int n = 1 << lg;
            for (int i = 1; i < n; ++i)
                if (i < (rev[i] >> (LG - lg)))
                    std::swap(a[i], a[rev[i] >> (LG - lg)]);
            for (int l = 1; l < n; l <<= 1)
                for (int i = 0, *k = w + l; i < n; i += (l << 1))
                    for (int j = i, *g = k; j < i + l; ++j, ++g) {
                        int tmp1 = a[j], tmp2 = mul(*g, a[j + l]);
                        a[j] = inc(tmp1, tmp2), a[j + l] = dec(tmp1, tmp2);
                    }
            if (inv) {
                reverse(a.begin() + 1, a.end());
                for (int i = 0, inv = Math::inv(n); i < n; ++i)
                    a[i] = mul(a[i], inv);
            }
        }

    public:
        Poly(int x = 0) { resize(x); }
        Poly(initializer_list<int> x) { assign(x); }

        int deg() const { return size() - 1; }

        void print() {
            for (int i : *this)
                cout << i << " ";
            cout << "\n";
        }

        Poly &operator%=(int a) {
            resize(a);
            return *this;
        }
        friend Poly operator%(Poly a, int b) { return a %= b; }

        Poly operator~() const {
            Poly ans = *this;
            reverse(ans.begin(), ans.end());
            return ans;
        }

        Poly &operator<<=(int a) {
            resize(size() + a);
            for (int i = a; i < (int)size(); ++i)
                at(i) = at(i - a);
            for (int i = 0; i < a; ++i)
                at(i) = 0;
            return *this;
        }
        friend Poly operator<<(Poly a, int b) { return a <<= b; }

        Poly &operator>>=(int a) {
            for (int i = a; i < (int)size(); ++i)
                at(i - a) = at(i);
            resize(size() - a);
            return *this;
        }
        friend Poly operator>>(Poly a, int b) { return a >>= b; }

        Poly &operator+=(const Poly &a) {
            if (a.size() > size())
                resize(a.size());
            for (int i = 0; i < (int)a.size(); ++i)
                at(i) = inc(at(i), a[i]);
            return *this;
        }
        friend Poly operator+(Poly a, const Poly &b) { return a += b; }

        Poly &operator-=(const Poly &a) {
            if (a.size() > size())
                resize(a.size());
            for (int i = 0; i < (int)a.size(); ++i)
                at(i) = dec(at(i), a[i]);
            return *this;
        }
        friend Poly operator-(Poly a, const Poly &b) { return a -= b; }

        Poly &operator*=(int a) {
            for (int &i : *this)
                i = mul(i, a);
            return *this;
        }
        friend Poly operator*(Poly a, int b) { return a *= b; }

        Poly &operator*=(Poly a) {
            int n = size(), m = a.size(), lg = getLen(n + m - 1);
            resize(1 << lg), a %= (1 << lg);
            ntt(*this, lg, false), ntt(a, lg, false);
            for (int i = 0; i < (1 << lg); ++i)
                at(i) = mul(at(i), a[i]);
            ntt(*this, lg, true);
            resize(n + m - 1);
            return *this;
        }
        friend Poly operator*(Poly a, const Poly &b) { return a *= b; }

        Poly &operator/=(const Poly &a) {
            int n = size(), m = a.size(), len = n - m + 1;
            if (n < m)
                return *this = Poly({0});
            *this = ~(((~*this) %= len) * inv((~a) % len, len) %= len);
            return *this;
        }
        friend Poly operator/(Poly a, const Poly &b) { return a /= b; }

        Poly &operator%=(const Poly &a) {
            Poly tmp = *this / a;
            *this -= a * tmp;
            return *this %= a.size() - 1;
        }
        friend Poly operator%(Poly a, const Poly &b) { return a %= b; }

        friend pair<Poly, Poly> divide(const Poly &a, const Poly &b) {
            Poly ans1 = a / b, ans2 = a - ans1 * b;
            return {ans1, ans2 %= b.size() - 1};
        }

        friend Poly inv(const Poly &a, int n) {
            Poly ans{Math::inv(a[0])};
            for (int lg = 2, len = 1; len < n; ++lg, len <<= 1) {
                Poly tmp = a % min(len << 1, (int)a.size());
                ans %= (len << 2), tmp %= (len << 2);
                ntt(ans, lg, false), ntt(tmp, lg, false);
                for (int i = 0; i < (len << 2); ++i)
                    ans[i] = mul(ans[i], dec(2, mul(ans[i], tmp[i])));
                ntt(ans, lg, true);
                ans %= (len << 1);
            }
            return ans %= n;
        }

        friend Poly der(const Poly &a) {
            int n = a.deg();
            Poly ans(n);
            for (int i = 0; i < n; ++i)
                ans[i] = mul(a[i + 1], i + 1);
            return ans;
        }
        friend Poly itr(const Poly &a) {
            if (!fac[0])
                getFac();
            int n = a.size();
            Poly ans(n + 1);
            for (int i = 1; i <= n; ++i)
                ans[i] = mul(a[i - 1], mul(iFac[i], fac[i - 1]));
            return ans;
        }

        friend Poly ln(const Poly &a, int n) { return itr(der(a) * inv(a, n) %= n) %= n; }
        friend Poly exp(const Poly &a, int n) {
            Poly ans{1}, tmp{1};
            for (int len = 1; len < n; len <<= 1)
                ans = ans * (tmp - ln(ans, len << 1) + a % (len << 1)) % (len << 1);
            return ans %= n;
        }
        friend Poly power(const Poly &a, int k, int n) { return exp(ln(a, n) * k, n); }
        friend Poly sqrt(const Poly &a, int n) {
            int inv2 = power(2, MOD - 2);
            Poly ans{Math::sqrt(a[0])};
            for (int len = 1; len < n; len <<= 1)
                ans = (ans + a % (len << 1) * inv(ans, len << 1)) * inv2 % (len << 1);
            return ans %= n;
        }
        friend Poly sin(const Poly &a, int n) {
            int i = Math::sqrt(MOD - 1);
            return (exp(a * i, n) - exp(a * (MOD - i), n)) * Math::inv(mul(i, 2));
        }
        friend Poly cos(const Poly &a, int n) {
            int i = Math::sqrt(MOD - 1);
            return (exp(a * i, n) + exp(a * (MOD - i), n)) * Math::inv(2);
        }
        friend Poly tan(const Poly &a, int n) {
            int i = Math::sqrt(MOD - 1);
            Poly tmp1 = exp(a * i, n), tmp2 = exp(a * (MOD - i), n);
            return (tmp1 - tmp2) * inv((tmp1 + tmp2) * i, n) %= n;
        }
        friend Poly asin(const Poly &a, int n) { return itr(der(a) * inv(sqrt(Poly({1}) - a * a %= n, n), n)) %= n; }
        friend Poly acos(const Poly &a, int n) { return itr(der(a) * inv(sqrt(Poly({1}) - a * a %= n, n), n)) %= n * (MOD - 1); }
        friend Poly atan(const Poly &a, int n) { return itr(der(a) * inv(Poly({1}) + a * a %= n, n)) %= n; }
    };
    int Poly::w[], Poly::rev[], Poly::fac[], Poly::iFac[];
    ```