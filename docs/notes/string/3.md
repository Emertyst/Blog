# AC 自动机

AC 自动机用于解决多模匹配问题。

## 思想

AC 自动机以 Trie 为结构基础，使用 KMP 的思想。具体来说，每个节点维护了一个 $fail$ 指针，表示从根节点到 $fail$ 指针所组成的字符串是根节点到当前节点的字符串的一个后缀，且是最长的真后缀。$fail$ 指针类似于 KMP 的 $\pi$ 函数，区别在于这里的 $fail$ 指针表示的前缀是在所有模式串中的，而 KMP 中只是当前模式串中的。我们需要先构建出模式串构成的 Trie，再求所有节点的 $fail$ 指针。在匹配时，和 KMP 相同，AC 自动机也是通过跳转 $fail$ 指针来匹配模式串。

## 定义

定义 Trie 的根节点编号为 $0$，节点 $u$ 的字符为 $\texttt{#}$ 的子节点是 $s(u, \texttt{#})$，节点 $u$ 的 $fail$ 指针为 $fail(u)$。定义字符集大小为 $|\sigma|$，Trie 节点数为 $n$。

## 复杂度不正确的构造

类比 KMP，假设我们已经求出 $fail(u)$ 指针，要求 $fail(s(u, \texttt{#}))$（$u$ 有字符为 $\texttt{#}$ 的子节点）。如果 $s(fail(u), \texttt{#})$ 存在，那么 $fail(s(u, \texttt{#})) = s(fail(u), \texttt{#})$；如果不存在，我们检查 $fail(fail(u))$，如果 $s(fail(fail(u)), \texttt{#})$ 存在，$fail(s(u, \texttt{#})) = s(fail(fail(u)), \texttt{#})$，如果仍不存在，就继续跳转 $fail$ 指针直到找到根，若 $s(0, \texttt{#})$ 仍不存在，$fail(s(u, \texttt{#})) = 0$。

!!! notes "复杂度不正确的构造"

    ```cpp
    void build() {
        queue<int> q;
        for (int i = 0; i < 26; ++i)
            if (son[0][i])
                q.emplace(son[0][i]);
        for (; !q.empty(); q.pop()) {
            int u = q.front();
            for (int i = 0; i < 26; ++i) {
                int x = fail[u];
                while (u && !son[x][i])
                    x = fail[x];
                fail[son[u][i]] = son[x][i];
            }
        }
    }
    ```

但是这样复杂度显然不正确，会被构造数据卡掉。

## 复杂度正确的构造

我们对 $s(u, \texttt{#})$ 进行一些修改，当 $u$ 没有字符为 $\texttt{#}$ 的子节点时，我们将 $s(u, \texttt{#})$ 赋值为 $s(fail(u), \texttt{#})$，这时，如果我们递归地寻找 $s(fail(u), \texttt{#})$，会出现两种情况：$fail(u)$ 本来就有 $\texttt{#}$ 的子节点和 $fail(u)$ 本来没有 $\texttt{#}$ 的子节点。如果是第二种情况，我们继续递归地寻找 $fail(fail(u)), fail(fail(fail(u))), \cdots$，直到找到一个本来就有 $\texttt{#}$ 的子节点的节点或根节点，这样，我们就找到了 $s(u, \texttt{#})$ 的本质。可以发现，这个过程就是不断跳转 $fail$ 指针直到找到深度最深的可以扩展节点，也就是复杂度不正确的构造中的不断跳转 $fail$ 指针的过程。因此，当 $u$ 有字符为 $\texttt{#}$ 的子节点时，我们只需要令 $fail(s(u, \texttt{#})) = s(fail(u), \texttt{#})$ 即可。

!!! notes "复杂度正确的构造"

    ```cpp
    void build() {
        queue<int> q;
        for (int i = 0; i < 26; ++i)
            if (son[0][i])
                q.emplace(son[0][i]);
        for (; !q.empty(); q.pop()) {
            int u = q.front();
            for (int i = 0; i < 26; ++i) {
                if (son[u][i])
                    fail[son[u][i]] = son[fail[u]][i], q.emplace(son[u][i]);
                else
                    son[u][i] = son[fail[u]][i];
            }
        }
    }
    ```

## 应用

### `query` 函数模板

!!! notes "query"

    ```cpp
    int query(char s[]) {
        int n = strlen(s), u = 0, ans = 0;
        for (int i = 0; i < n; ++i) {
            u = son[u][s[i] - 'a'];
            for (int j = u; j; j = fail[j])
                if (cnt[j]) {
                    // do something
                }
        }
        return ans;
    }
    ```

    `cnt` 表示当前节点是几个模式串的结尾。

因为我们改变了 $s(u, \texttt{#})$，所以第四行的赋值就相当于不断跳转 $fail$ 指针直到可以匹配。第五行使用 `for` 循环跳转 $fail$ 指针而不是 `if` 判断当前节点是否是一个模式串的结尾是因为一个匹配的模式串不一定就是最长的后缀。

可以看出，这个函数的复杂度不太正确，因此我们需要在应用时对其进行调整。

### 统计模式串是否出现

!!! notes "统计模式串是否出现"

    给定 $n$ 个模式串和一个字符串 $s$，每个模式串互不相同，求哪些模式串在 $s$ 中出现了。

我们只需要统计每个表示模式串结尾的节点是否被访问即可，因此我们可以将访问过的节点标记，在 `for` 循环跳转 $fail$ 指针时如果访问到了这些节点，那么可以直接退出循环。每个节点最多被访问一次，因此时间复杂度为 $O(n + |s|)$。

### 统计模式串出现次数

!!! notes "统计模式串出现次数"

    给定 $n$ 个模式串和一个字符串 $s$，每个模式串互不相同，求每个模式串在 $s$ 中出现次数。

我们需要求出每个表示模式串结尾的节点被访问的次数。可以发现，所有 $fail$ 指针构成了一个内向树，根即为 Trie 的根。因此，`for` 循环跳转 $fail$ 指针就相当于从一个节点一直跳转到根。在匹配时，我们可以选择不跳转，而是记录每个点在匹配时被访问的次数，在匹配结束之后再按拓扑序跳转，这样就保证了跳转 $fail$ 指针时每个节点只被访问了一次，因此时间复杂度 $O(n + |s|)$。

另外，由于在构建 $fail$ 指针时，我们总是将一个节点的 $fail$ 指针指向之前访问过的节点，因此拓扑序就是构建时 BFS 序的倒序。