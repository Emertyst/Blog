在 WinAPI 程序中使用了许多在 OI 中很难涉及的东西，因此需要补充前置知识。

## 指针

### 指针的 `const` 修饰

`const` 可以修饰数据类型，也可以修饰指针变量。

#### 修饰数据类型

`const` 修饰数据类型时，指针指向的地址可以改变，但指针指向的地址所对应的内容不可以改变。

```cpp
int a = 0, b = 0;
const int *p = &a;
*p = 1; // 错误
p = &b; // 正确
```

#### 修饰指针变量

`const` 修饰指针变量时，指针指向的地址不可以改变，但指针指向的地址所对应的内容可以改变。

```cpp
int a = 0, b = 0;
int *const p = &a;
*p = 1; // 正确
p = &b; // 错误
```

!!! tip

    修饰指针变量时，`*const` 只作用于后面的变量，如果有 `int *const p = &a, c = 0;`，那么 `c` 只是一个 `int` 型的变量；修饰数据类型时，`const` 作用于数据类型，可以作用于同一个语句中定义的所有变量，即 `const int *p = &a, c = 0;` 中 `c` 的数据类型为 `const int`。

    值得注意的是，`const int` 和 `int const` 等价，即 `int const a = 0, b = 0;` 中 `a` 和 `b` 都是 `const int` 类型。

### 指针的 `typedef`

指针的 `typedef` 写作 `typedef int *Pint;`，在声明变量时，`Pint p;` 就和 `int *p;` 等价了。同样，若 `typedef const int *Pint;`，则 `Pint p;` 和 `const int *p;` 等价；若 `typedef int *const Pint;`，则 `Pint p;` 和 `int *const p;` 等价。值得注意的是，若 `typedef int *Pint;`，则 `const Pint p;` 与 `Pint *const p;` 等价。

至于 `const` 的作用范围，`typedef const int *Pint, tni;` 中 `const` 修饰 `int`，即 `tni` 为 `const int` 类型；`typedef int *const Pint, tni;` 中 `*const` 修饰 `Pint`，即 `tni` 为 `int` 类型。